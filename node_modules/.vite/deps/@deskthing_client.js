import {
  CLIENT_REQUESTS,
  ClientPlatformIDs,
  DEVICE_CLIENT,
  EventMode,
  LOGGING_LEVELS
} from "./chunk-F7RSZWBU.js";
import "./chunk-BUSYA2B4.js";

// node_modules/@deskthing/client/dist/deskthing.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DeskThingClass = class _DeskThingClass {
  /**
   * Initializes the DeskThing instance and sets up event listeners.
   * Sends a message to the parent indicating that the client has started.
   * Also sets up a click event listener for buttons.
   * @version 0.10.4
   */
  constructor() {
    this.listeners = {};
    this.onceListenerKeys = /* @__PURE__ */ new Set();
    this.keyOverrides = /* @__PURE__ */ new Set();
    this.fetch = (requestData, listenFor, callbackFn) => __awaiter(this, void 0, void 0, function* () {
      if (!requestData.type) {
        console.warn("Request data must have a type property");
        return void 0;
      }
      if (!listenFor)
        return;
      if (!listenFor.type) {
        console.warn("Listen for data must have a type property");
        return void 0;
      }
      const listenKey = `${listenFor.type}-${listenFor.request || "undefined"}`;
      const timeout = new Promise((_, reject) => {
        setTimeout(() => {
          return reject(new Error(`Timed out waiting for response: type=${listenFor.type}, request=${listenFor.request || "undefined"}`));
        }, 5e3);
      });
      let removeListener;
      const dataPromise = new Promise((resolve) => {
        removeListener = this.once(listenFor.type, (data2) => {
          this.onceListenerKeys.delete(listenKey);
          resolve(data2);
        }, listenFor.request);
        if (!this.onceListenerKeys.has(listenKey)) {
          this.send(requestData);
          this.onceListenerKeys.add(listenKey);
        }
      });
      const data = Promise.race([dataPromise, timeout]).catch((error) => {
        this.error(error);
        removeListener && removeListener();
        this.onceListenerKeys.delete(listenKey);
        return void 0;
      });
      if (callbackFn) {
        data.then((data2) => callbackFn(data2));
      }
      return data;
    });
    this.fetchData = (type, requestData, request) => __awaiter(this, void 0, void 0, function* () {
      return this.fetch(
        requestData,
        { type, request }
        // Not good typing - but this is depreciated
      );
    });
    this.getMusic = () => __awaiter(this, void 0, void 0, function* () {
      const socketResponse = yield this.fetch({
        app: "client",
        type: CLIENT_REQUESTS.GET,
        request: "music"
      }, {
        type: DEVICE_CLIENT.MUSIC
      });
      if (!socketResponse)
        return void 0;
      const musicData = socketResponse.payload;
      if (musicData && musicData.thumbnail) {
        musicData.thumbnail = this.formatImageUrl(musicData.thumbnail);
      }
      return musicData;
    });
    this.getSettings = () => __awaiter(this, void 0, void 0, function* () {
      const socketResponse = yield this.fetch({
        app: "client",
        type: CLIENT_REQUESTS.GET,
        request: "settings"
      }, {
        type: DEVICE_CLIENT.SETTINGS
      });
      if (!socketResponse)
        return void 0;
      return socketResponse.payload;
    });
    this.getApps = () => __awaiter(this, void 0, void 0, function* () {
      const socketResponse = yield this.fetch({
        app: "client",
        type: CLIENT_REQUESTS.GET,
        request: "apps"
      }, {
        type: DEVICE_CLIENT.APPS
      });
      if (!socketResponse)
        return void 0;
      return socketResponse.payload;
    });
    this.getKeyIcon = (KeyReference) => __awaiter(this, void 0, void 0, function* () {
      const socketResponse = yield this.fetch({
        app: "client",
        type: CLIENT_REQUESTS.GET,
        request: "key",
        payload: KeyReference
      }, { type: KeyReference.id });
      if (!socketResponse)
        return void 0;
      return socketResponse.payload;
    });
    this.getActionIcon = (action) => __awaiter(this, void 0, void 0, function* () {
      const socketResponse = yield this.fetch({
        app: "client",
        type: CLIENT_REQUESTS.GET,
        request: "action",
        payload: action
      }, { type: action.id });
      if (!socketResponse)
        return void 0;
      return socketResponse.payload;
    });
    this.triggerAction = (action) => __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      this.send({
        app: "client",
        type: CLIENT_REQUESTS.ACTION,
        payload: Object.assign(Object.assign({}, action), { enabled: (_a = action.enabled) !== null && _a !== void 0 ? _a : true, source: action.source || ((_b = this.manifest) === null || _b === void 0 ? void 0 : _b.id) || "server" })
      });
    });
    this.triggerKey = (KeyReference) => __awaiter(this, void 0, void 0, function* () {
      var _a;
      if (!KeyReference.source) {
        KeyReference.source = ((_a = this.manifest) === null || _a === void 0 ? void 0 : _a.name) || "server";
      }
      this.send({
        app: "client",
        type: CLIENT_REQUESTS.KEY,
        payload: KeyReference
      });
    });
    this.getManifest = () => __awaiter(this, void 0, void 0, function* () {
      if (this.manifest) {
        return this.manifest;
      }
      const socketResponse = yield this.fetch({
        app: "client",
        type: CLIENT_REQUESTS.GET,
        request: "manifest"
      }, {
        type: DEVICE_CLIENT.MANIFEST
      });
      if (!socketResponse)
        return void 0;
      this.manifest = socketResponse.payload;
      return socketResponse.payload;
    });
    this.formatImageUrl = (image) => {
      var _a, _b, _c, _d, _e;
      if (!((_a = this.manifest) === null || _a === void 0 ? void 0 : _a.context)) {
        return image;
      }
      if (image.startsWith("data:image")) {
        return image;
      }
      if (this.manifest.context.id == ClientPlatformIDs.CarThing || this.manifest.context.ip == "localhost") {
        return image.replace("localhost:8891", `${((_c = (_b = this.manifest) === null || _b === void 0 ? void 0 : _b.context) === null || _c === void 0 ? void 0 : _c.ip) || "localhost"}:${((_e = (_d = this.manifest) === null || _d === void 0 ? void 0 : _d.context) === null || _e === void 0 ? void 0 : _e.port) || 8891}`);
      }
      return image;
    };
    this.useProxy = (url) => {
      var _a, _b, _c, _d;
      if (url.startsWith("data:image")) {
        return url;
      }
      return `http://${((_b = (_a = this.manifest) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.ip) || "localhost"}:${((_d = (_c = this.manifest) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.port) || 8891}/proxy/v1?url=${encodeURIComponent(url)}`;
    };
    this.initialize();
    this.initializeListeners();
  }
  /**
   * Initializes the message event listener.
   * @private
   * @version 0.10.4
   */
  initialize() {
    window.addEventListener("message", this.handleMessage.bind(this));
  }
  /**
   * Sets up the listeners and bubbles them to the server
   * @private
   * @version 0.10.4
   */
  initializeListeners() {
    return __awaiter(this, void 0, void 0, function* () {
      const eventsToForward = ["wheel", "keydown", "keyup"];
      const forwardEvent = (event) => {
        if (event.defaultPrevented) {
          return;
        }
        if (event instanceof KeyboardEvent) {
          const key = event.code;
          if (this.keyOverrides.has(key.toLowerCase())) {
            return;
          }
          const mode = event.type === "keydown" ? EventMode.KeyDown : EventMode.KeyUp;
          this.triggerKey({ id: key, mode });
        } else if (event instanceof WheelEvent) {
          if (this.keyOverrides.has("wheel")) {
            return;
          }
          let mode = EventMode.ScrollUp;
          if (event.deltaY > 0)
            mode = EventMode.ScrollDown;
          else if (event.deltaY < 0)
            mode = EventMode.ScrollUp;
          else if (event.deltaX > 0)
            mode = EventMode.ScrollRight;
          else if (event.deltaX < 0)
            mode = EventMode.ScrollLeft;
          this.triggerKey({ id: "Scroll", mode });
        }
      };
      const options = {
        capture: true,
        passive: false
      };
      eventsToForward.forEach((eventType) => {
        document.addEventListener(eventType, forwardEvent, options);
      });
      const fetchManifest = () => __awaiter(this, void 0, void 0, function* () {
        this.manifest = yield this.fetchData("manifest", {
          type: CLIENT_REQUESTS.GET,
          request: "manifest",
          app: "client"
        });
      });
      const handleManifest = (socketData) => __awaiter(this, void 0, void 0, function* () {
        if (socketData.type == DEVICE_CLIENT.MANIFEST && socketData.payload) {
          this.info("Received the manifest from the server");
          this.manifest = socketData.payload;
        }
      });
      fetchManifest();
      this.on(DEVICE_CLIENT.MANIFEST, handleManifest);
    });
  }
  /**
  * Prevents default DeskThing handling for specific keys
  * @param keys - Array of key codes to override (e.g., ['KeyA', 'Enter', 'Space'])
  * @example
  * deskThing.overrideKeys(['KeyA', 'Enter', 'Scroll']);
  */
  overrideKeys(keys) {
    keys.forEach((key) => this.keyOverrides.add(key.toLowerCase()));
  }
  /**
   * Removes key overrides
   * @param keys - Array of key codes to restore default
   * @example
   * deskThing.restoreKeys(['KeyA', 'Enter', 'Scroll']);
   */
  restoreKeys(keys) {
    keys.forEach((key) => this.keyOverrides.delete(key.toLowerCase()));
  }
  /**
   * Singleton pattern: Ensures only one instance of DeskThing exists.
   * @returns {DeskThingClass} The single instance of DeskThing
   * @version 0.10.4
   *
   * @example
   * const deskThing = DeskThing.getInstance();
   */
  static getInstance() {
    if (!this.instance) {
      this.instance = new _DeskThingClass();
    }
    return this.instance;
  }
  /**
   * Registers an event listener for a specific event type.
   * @param {string} type - The type of event to listen for
   * @param {EventCallback} callback - The function to call when the event occurs
   * @returns {Function} A function to remove the event listener
   * @version 0.10.4
   *
   * @example
   * const removeListener = deskThing.on('music', (data: SocketData) => {
   *   console.log('Received music data:', data.payload);
   * });
   *
   * @example
   * // Client-side code (here)
   * const removeListener = deskThing.on('customdata', (data: SocketData) => {
   *   console.log('Received custom data:', data.payload);
   * });
   *
   * // Server-side code
   * DeskThing.send({ type: 'customdata', payload: 'Hello from the server!' });
   */
  on(type, callback) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(callback);
    return () => this.off(type, callback);
  }
  /**
   * Removes an event listener for a specific event type.
   * @param {string} type - The type of event to remove the listener from
   * @param {EventCallback} callback - The function to remove from the listeners
   * @version 0.10.4
   *
   * @example
   * deskThing.off('message', messageCallback);
   */
  off(type, callback) {
    if (this.listeners[type]) {
      this.listeners[type] = this.listeners[type].filter((listener) => listener !== callback);
    }
  }
  /**
   * Handles incoming messages from the parent window.
   * @param {MessageEvent} event - The message event received
   * @private
   * @version 0.10.4
   */
  handleMessage(event) {
    if (event.data.source !== "deskthing")
      return;
    const socketData = event.data;
    this.emit(socketData.type, socketData);
  }
  /**
   * Emits an event to all registered listeners for that event type.
   * @param {string} type - The type of event to emit
   * @param {SocketData} data - The data to pass to the event listeners
   * @returns {Promise<void>}
   * @private
   * @version 0.10.4
   */
  emit(type, data) {
    return __awaiter(this, void 0, void 0, function* () {
      const callbacks = this.listeners[type];
      if (callbacks) {
        const promises = callbacks.map((callback) => __awaiter(this, void 0, void 0, function* () {
          try {
            yield callback(data);
          } catch (error) {
            console.error("Error in event callback:", error);
          }
        }));
        Promise.all(promises);
      }
      const listenKey = `${type}-${data.request || "undefined"}`;
      const res = this.onceListenerKeys.delete(listenKey);
      if (res) {
        this.debug(`Removed callback key ${listenKey} because the callback was resolved`);
      }
    });
  }
  /**
   * Listens for a single occurrence of an event, then removes the listener
   * @param {string} type - The event type to listen for
   * @param {EventCallback} callback - The function to call when the event occurs
   * @returns {Function} - Function to manually remove the listener
   * @version 0.10.4
   *
   * @example
   * deskThing.once('music', (data) => {
   *   console.log('Received music data:', data.payload);
   * });
   *
   * @example
   * // Client-side code (here)
   * deskThing.once('data', (data) => {
   *   console.log('Received specific request:', data.payload); // prints Payload 3 once
   * }, 'specificRequest');
   *
   *  // Server-side code
   * DeskThing.send({ type: 'data', payload: 'Payload 1', request: 'someRequest' }); // Wont send
   * DeskThing.send({ type: 'data', payload: 'Payload 2', request: 'randomRequest' }); // Wont send
   * DeskThing.send({ type: 'data', payload: 'Payload 3', request: 'specificRequest' }); // Will send
   * DeskThing.send({ type: 'data', payload: 'Payload 4', request: 'faultyRequest' }); // Wont send
   * DeskThing.send({ type: 'data', payload: 'Payload 5', request: 'specificRequest' }); // Wont send
   */
  once(type, callback, request) {
    const removeListener = this.on(type, (data) => {
      if (request && data.request !== request)
        return;
      callback(data);
      removeListener();
    });
    return removeListener;
  }
  /**
   * Sends a message to the parent window.
   * @param {SocketData} data - The data to send to the parent. "app" defaults to the current app
   * @deprecated Use send() instead
   * @example
   * deskThing.sendMessageToParent({
   *   app: 'client',
   *   type: 'action',
   *   payload: { buttonClicked: 'submit' }
   * });
   */
  sendMessageToParent(data) {
    this.send(data);
  }
  /**
   * Sends a message to the parent window.
   * @param {SocketData} data - The data to send to the parent. "app" defaults to the current app
   *
   * @example
   * deskThing.send({
   *   app: 'client',
   *   type: 'action',
   *   payload: { buttonClicked: 'submit' }
   * });
   */
  send(data) {
    var _a;
    const payload = {
      app: data.app || void 0,
      type: data.type || void 0,
      request: data.request || null,
      payload: (_a = data.payload) !== null && _a !== void 0 ? _a : null
    };
    window.parent.postMessage({ type: "IFRAME_ACTION", payload }, "*");
  }
  /**
   * Logs the message in the console, the client, and the server
   * The extra data logged will not be bubbled anywhere but the console
   *
   * @example
   * DeskThing.log(LOGGING_LEVELS.INFO, 'This is an info message', 'this is extra data');
   * // logs "[CLIENT]: This is an info message this is extra data" to the console
   * // logs "[YourApp] This is an info message" to the client
   * // logs "[CLIENT.YourApp] This is an info message" to the server
   */
  log(level, message, ...extraData) {
    this.send({
      app: "client",
      type: CLIENT_REQUESTS.LOG,
      request: level,
      payload: { message, data: [...extraData] }
    });
  }
  /**
   * Logs the message in the console, the client, and the server
   * The extra data logged will not be bubbled anywhere but the console
   *
   * @example
   * DeskThing.error('This is an error message', 'this is extra data');
   * // logs "[CLIENT]: This is an error message this is extra data" to the console
   * // logs "[YourApp] This is an error message" to the client
   * // logs "[CLIENT.YourApp] This is an error message" to the server
   */
  error(message, ...extraData) {
    this.log(LOGGING_LEVELS.ERROR, message, ...extraData);
  }
  /**
   * Logs the message in the console, the client, and the server
   * The extra data logged will not be bubbled anywhere but the console
   *
   * @example
   * DeskThing.warn('This is a warning message', 'this is extra data');
   * // logs "[CLIENT]: This is a warning message this is extra data" to the console
   * // logs "[YourApp] This is a warning message" to the client
   * // logs "[CLIENT.YourApp] This is a warning message" to the server
   */
  warn(message, ...extraData) {
    this.log(LOGGING_LEVELS.WARN, message, ...extraData);
  }
  /**
   * Logs the message in the console, the client, and the server
   * The extra data logged will not be bubbled anywhere but the console
   *
   * @example
   * DeskThing.debug('This is a debug message', 'this is extra data');
   * // logs "[CLIENT]: This is a debug message this is extra data" to the console
   * // logs "[YourApp] This is a debug message" to the client
   * // logs "[CLIENT.YourApp] This is a debug message" to the server
   */
  debug(message, ...extraData) {
    this.log(LOGGING_LEVELS.DEBUG, message, ...extraData);
  }
  /**
   * Logs the message in the console, the client, and the server
   * The extra data logged will not be bubbled anywhere but the console
   *
   * @example
   * DeskThing.fatal('This is a fatal message', 'this is extra data');
   * // logs "[CLIENT]: This is a fatal message this is extra data" to the console
   * // logs "[YourApp] This is a fatal message" to the client
   * // logs "[CLIENT.YourApp] This is a fatal message" to the server
   */
  fatal(message, ...extraData) {
    this.log(LOGGING_LEVELS.FATAL, message, ...extraData);
  }
  /**
   * Logs the message in the console, the client, and the server
   * The extra data logged will not be bubbled anywhere but the console
   *
   * @example
   * DeskThing.info('This is an info message', 'this is extra data');
   * // logs "[CLIENT]: This is an info message this is extra data" to the console
   * // logs "[YourApp] This is an info message" to the client
   * // logs "[CLIENT.YourApp] This is a fatal message" to the server
   */
  info(message, ...extraData) {
    this.log(LOGGING_LEVELS.LOG, message, ...extraData);
  }
};
function createDeskThing() {
  return DeskThingClass.getInstance();
}
var DeskThing = createDeskThing();
export {
  DeskThing,
  DeskThingClass,
  createDeskThing
};
//# sourceMappingURL=@deskthing_client.js.map
